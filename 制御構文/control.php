<?php

//4.3 ループの制御
/*
4.3.1 break命令
→ break命令は、現在のループを強制的に中断する命令です。
  下記は1～100の値を加算していき、合計値が1000を超えたところでループを脱出するもの。
*/
$sum = 0;
for($i = 1;$i <= 100;$i++){
    $sum += $i;
    if($sum > 1000){
        break;
    }
}
print "合計が1000を超えるのは、1～{$i}を加算したときです。";
//結果：合計が1000を超えるのは、1～45を加算したときです。

/* 
4.3.2 continue命令 
→ ループそのものを完全に抜けてしまうbreak命令に対して、現在の周回だけをスキップし、ループそのものは継続して実行するのが、continue命令の役割です。 
下記は1～100の範囲で偶数値のみを加算し、その合計値を求める。 
*/ 
$sum = 0; 
for($i = 1;$i <=100;$i++){ 
    if($i % 2 !== 0){ 
        continue; 
    } 
    $sum += $i; 
} 
print"合計値は{$sum}です。";//結果：合計値は2550です。

print '<br/>';
/*
4.3.3 入れ子のループを中断/スキップする。
→ ネストされたループの中で、break／continue命令を使用した場合、既定では最も内側のループを脱出／スキップする。
下記は九九表を作成するためのサンプルです。ただし、各段ともに40を超えた値は表示しないものとします。
これによって内側のループを脱出するので、結果として、積が40以下である九九表を出力できるわけです。
*/
for($i = 1;$i <= 10;$i++){
    for($j = 1; $j < 10; $j++){
        $result = $i * $j;
        if($result > 40){
            break;
        }
        print "{$result} &nbsp";
    }
    print '<br />';
}
/*
実行結果
1  2  3  4  5  6  7  8  9  
2  4  6  8  10  12  14  16  18  
3  6  9  12  15  18  21  24  27  
4  8  12  16  20  24  28  32  36  
5  10  15  20  25  30  35  40  
6  12  18  24  30  36  
7  14  21  28  35  
8  16  24  32  40  
9  18  27  36  
10  20  30  40  
*/

/*
これに対して、一度でも積が40を超えたら九九表の出力自体を停止したい、としたらどうでしょう。
break命令の末尾に脱出するループの階層を指定するのです。
ここでは2を指定しているので、内側／外側の二重ループをまとめて脱出します。
結果を見ても、現在の（内側の）ループではなく、外側のforループを一気に脱出していることが確認できます。
*/

for($i = 1;$i <= 10;$i++){
    for($j = 1; $j < 10; $j++){
        $result = $i * $j;
        if($result > 40){
            break 2;
        }
        print "{$result} &nbsp";
    }
    print '<br />';
}
/* 
実行結果
1  2  3  4  5  6  7  8  9  
2  4  6  8  10  12  14  16  18  
3  6  9  12  15  18  21  24  27  
4  8  12  16  20  24  28  32  36  
5  10  15  20  25  30  35  40  
*/

print '<br/>';
/*
4.3.4 switchブロック配下のcontinue命令
switchブロックの中では、continue命令はbreak命令と同じように動作するので要注意である。
*/
//$iを1～3で変化させるループ
for($i = 1;$i < 4;$i++){
    $result = 0;
    switch($i){
        case 1:
        case 3://$i=1、3の場合のみ変数$resultを計算
            $result= $i * $i;
        break;
        case 2:
        continue;
    }
    print "{$i}の2乗は{$result}です。<br/>";
}
/*
期待の結果
1の2乗は1です。3の2乗は9です。
*/
/*
実際の結果
Warning: "continue" targeting switch is equivalent to "break". Did you mean to use "continue 2"?
1の2乗は1です。
2の2乗は0です。
3の2乗は9です。
*/
//「$i=2」の周回をスキップさせたい場合には、太字部分を「continue 2;」のように書き換える必要がある。

print '<br/>';
//4.4 制御命令のその他の話題
/*
4.4.1 goto命令
→ goto命令を利用することで、スクリプトの処理を強制的に他に移動できます
  goto命令を利用する場合には、まず移動先を表すラベルを明記する必要があります。
  ラベルは次の形式で指定し、ラベル名には2.1.2項に従う任意の名前を付けることができます。
 （末尾はセミコロンではなく、コロンです！）
*/
for($i = 1;$i < 10;$i++){
    for($j = 1;$j < 10;$j++){
        $result = $i * $j;
        if($result > 40){
            goto end;
        }
        print "{$result}&nbsp;";
    }
    print '<br/>';}
end:
/*
結果
1 2 3 4 5 6 7 8 9 
2 4 6 8 10 12 14 16 18 
3 6 9 12 15 18 21 24 27 
4 8 12 16 20 24 28 32 36 
5 10 15 20 25 30 35 40 
*/
//注意点
/*
（1）どこへでも移動できるわけではない
goto命令を使えば、無条件にどこへでも移動できるわけではありません。goto命令には、次のような制限があります。
●異なるファイルには移動できない
●関数やクラス／メソッド（後述）の中には移動できない
●ループの外からループの内部には移動できない
*/
/*
（2）濫用すべきではない
goto命令は、多くの場合、スクリプトの流れを読みにくくする原因になります。
（goto命令であちこちに飛び回るコードのことを、俗にスパゲッティコードと呼びます）。
そのため、そもそもgoto命令は利用すべきではない、と主張するプログラマーも多くいます。
*/
print '<br/>';
?>

<!-- 4.4.2 スクリプトブロックと固定テンプレート
スクリプティングデリミタ（'<?php ?>'）で囲まれたスクリプトブロックに対して、
それ以外の箇所 ── 固定的なHTMLソースのことを固定テンプレートまたはHTMLテンプレートと呼びます。
スクリプトブロックと固定テンプレートとは、入れ子に記述することも可能です。

コードの可読性を考慮すると、あまりに細かくスクリプトブロックと固定テンプレートとを切り分けるのは好ましいことではありません。
しかし、ある程度まとまった文字列の出力がスクリプトブロックに含まれている場合には、
積極的に固定テンプレートに切り出すことで、コードをよりシンプルに記述できるでしょう。
-->
<?php for( $i = 1;$i < 3;$i++) {?>
    <p>こんにちは、世界!</p>
<?php } ?>
<!-- 結果 こんにちは、世界! こんにちは、世界! -->

<?php
/* 4.4.3 制御命令の別構文
if、switch、while、for、foreach命令には、これまでに示したものの他にもう1つ構文があります。
中カッコ（{～}）の代わりに、開始の中カッコをコロン（:）、終了の中カッコを「endif;」「endswitch;」「endwhile;」「endfor;」「endforeach;」のいずれかにする構文です。
*/
$x = 35;
if($x > 20):
    print'変数$xは20より大きいです。';
elseif($x > 10):
    print'変数$xは10より大きく、20以下です。';
else:
    print'変数$xは10以下です。';
endif;
//結果 変数$xは20より大きいです。